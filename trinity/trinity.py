from typing import (
    List,
    Dict,
    Any,
    Optional,
    Union,
    Callable,
    Sequence,
)
from textwrap import dedent
from pydantic import BaseModel, Field

from agno.models.base import Model
from agno.tools.toolkit import Toolkit
from agno.models.message import  Message
from agno.media import (
    Audio,
    File,
    Image,
    Video,
)

from agno.agent import Agent, RunResponse
from agno.utils.log import logger


class Trinity:
    """
    trinity is a mini group of agents that can be used to do a task.
    it includes a worker, a checker and a arbitrator.
    if needed, it can be extended with a restorer.
    worker do the input task, and checker check the result, and arbitrator arbitrate the result.
    if needed, restorer restore the environment.
    """

    # --- Agent Trinity settings ---
    # trinity name
    name: Optional[str] = None
    # trinity model, if model, for all agents, if list, for each agent
    model: Union[Model, List[Model], None] = None
    # trinity UUID (autogenerated if not set)
    trinity_id: Optional[str] = None
    # worker Agent introduction. This is added to the message history when a run is started.
    introduction: Optional[str] = None

    # --- Settings for building the default system message ---
    # A description of the trinity that is added to the start of the system message.
    description: Optional[str] = None
    # List of instructions for the agent.
    instructions: Optional[Union[str, List[str], Callable]] = None

    # --- User settings ---
    # ID of the user interacting with this trinity
    user_id: Optional[str] = None

    # --- Trinity tools ---
    mcp_tools: Optional[Toolkit] = None

    # --- restore agent ---
    # if needed, restore the environment
    need_restore: bool = False

    def __init__(
        self,
        *,
        model: Union[Model, List[Model]],
        name: Optional[str] = None,
        trinity_id: Optional[str] = None,
        introduction: Optional[str] = None,
        description: Optional[str] = None,
        instructions: Optional[Union[str, List[str], Callable]] = None,
        user_id: Optional[str] = None,
        mcp_tools: Optional[Toolkit] = None,
        need_restore: bool = False,
    ):
        self.model = model
        self.name = name or self.__class__.__name__
        self.trinity_id = trinity_id
        self.introduction = introduction
        self.description = description
        self.instructions = instructions
        self.user_id = user_id
        self.mcp_tools = [mcp_tools] if isinstance(mcp_tools, Toolkit) else None
        self.need_restore = need_restore

    def _create_worker(self):
        worker_model = self.model if isinstance(self.model, Model) else self.model[0]
        self.worker = Agent(
            model=worker_model,
            tools=self.mcp_tools,
            name=f"{self.name} Worker",
            instructions=self.instructions,
            response_model=WorkerResponse,
            markdown=True,
            show_tool_calls=True,
        )

    def _create_checker(self):
        checker_model = self.model if isinstance(self.model, Model) else self.model[1]
        self.checker = Agent(
            model=checker_model,
            tools=self.mcp_tools,
            name=f"{self.name} Checker",
            instructions=dedent(
                """\
                You are a Worker Response Checker with the following responsibilities:
                -Quality Verification:
                    --Examine the worker's deliverables against the user's requirements
                    --Evaluate both:
                        ---Whether the output meets the user's needs
                        ---Whether the delivered work matches the worker's initial response
                -Approval Criteria:
                    --Approve the submission ONLY when:
                        ---The deliverables fully satisfy the user's requirements, AND
                        ---The final output is consistent with the worker's stated response
                    --Reject the submission if either condition is not met
                -Rejection Protocol:
                    --When rejecting, you MUST provide:
                        ---Detailed reasons for rejection
                        ---Specific discrepancies found
                        ---Clear explanations of how the submission failed to meet requirements
                -Arbitration Compliance:
                    --If the Arbitrator overturns your decision:
                        ---Re-evaluate the worker's deliverables incorporating the Arbitrator's findings
                        ---Issue a new determination based on the updated assessment
                        ---Document any changes to the original evaluation\
            """
            ),
            response_model=CheckerResponse,
            markdown=True,
            show_tool_calls=True,
        )

    def _create_arbitrator(self):
        arbitrator_model = (
            self.model if isinstance(self.model, Model) else self.model[2]
        )
        self.arbitrator = Agent(
            model=arbitrator_model,
            tools=self.mcp_tools,
            name=f"{self.name} Arbitrator",
            instructions=dedent(
                """\
                You are an Arbitrator with the following responsibilities:
                -Arbitration Process:
                    --Review both the worker's completed task and the checker's evaluation.
                    --Independently assess whether the worker's output meets the user's requirements (if necessary).
                -Final Arbitration Decision:
                    --Determine whether the checker's rejection of the worker's submission was correct or incorrect.
                    --Provide a detailed justification for your ruling, including:
                        ---Whether the worker’s output truly complied with user requirements.
                        ---Whether the checker’s assessment was fair and accurate.\
            """
            ),
            response_model=ArbitratorResponse,
            markdown=True,
            show_tool_calls=True,
        )

    def _create_restorer(self):
        restorer_model = self.model if isinstance(self.model, Model) else self.model[0]
        self.restorer = Agent(
            model=restorer_model,
            tools=self.mcp_tools,
            name=f"{self.name} Restorer",
            instructions=dedent(
                """\
                You are a Restorer with the following responsibilities:
                -Restore Environment:
                    --Restore the environment to the original state.
                    --Provide a detailed explanation of how the environment was restored.\
            """
            ),
            markdown=True,
            show_tool_calls=True,
        )

    async def arun(
        self,
        message: Optional[Union[str, List, Dict, Message]] = None,
        *,
        audio: Optional[Sequence[Audio]] = None,
        images: Optional[Sequence[Image]] = None,
        videos: Optional[Sequence[Video]] = None,
        files: Optional[Sequence[File]] = None,
        messages: Optional[Sequence[Union[Dict, Message]]] = None,
        retries: Optional[int] = None,
        **kwargs: Any,
    ) -> Any:
        self._create_worker()
        self._create_checker()
        self._create_arbitrator()
        for mcp_tool in self.mcp_tools:
            await mcp_tool.__aenter__()
        try:
            worker_response: RunResponse = await self.worker.arun(
                message=message,
                audio=audio,
                images=images,
                videos=videos,
                files=files,
                messages=messages,
                retries=retries,
                **kwargs,
            )
            if worker_response is None or not worker_response.content:
                return RunResponse(
                    content="Sorry, worker could not provide a response."
                )

            checker_retry_times = 0
            checker_recheck_times = 0

            checker_response = None
            arbitrator_response = None
            while checker_recheck_times < 3:
                while checker_retry_times < 3:
                    if arbitrator_response is None:
                        arbitrator_response_content = ''
                    else:
                        arbitrator_response_content = str(arbitrator_response.content)
                    checker_response: RunResponse = await self.checker.arun(
                        message=f"user message: {message}, worker response: {str(worker_response.content)}, arbitrator response: {arbitrator_response_content}",
                        audio=audio,
                        images=images,
                        videos=videos,
                        files=files,
                        messages=messages,
                        retries=retries,
                        **kwargs,
                    )
                    if checker_response is None or not checker_response.content:
                        checker_retry_times += 1
                        continue
                    else:
                        break

                if checker_response is None or not checker_response.content:
                    return RunResponse(
                        content="Sorry, checker could not provide a response."
                    )

                # If checker passes, return the worker's response directly
                if checker_response.content.status:
                    return checker_response

                arbitrator_retry_times = 0
                while arbitrator_retry_times < 3:
                    arbitrator_response: RunResponse = await self.arbitrator.arun(
                        message=f"user message: {message}, worker response: {str(worker_response.content)}, checker response: {str(checker_response.content)}",
                        audio=audio,
                        images=images,
                        videos=videos,
                        files=files,
                        messages=messages,
                        retries=retries,
                        **kwargs,
                    )
                    if arbitrator_response is None or not arbitrator_response.content:
                        arbitrator_retry_times += 1
                        continue
                    else:
                        break
                if arbitrator_response is None or not arbitrator_response.content:
                    return RunResponse(
                        content="Sorry, arbitrator could not provide a response."
                    )

                if arbitrator_response.content.status:
                    return arbitrator_response
                else:
                    checker_recheck_times += 1
                    continue

            if self.need_restore:
                self._create_restorer()
                # restore the environment
                restore_retry_times = 0
                while restore_retry_times < 3:
                    restorer_response: RunResponse = await self.restorer.arun(
                        message=f"user message: {message}, worker response: {worker_response.content}",
                        audio=audio,
                        images=images,
                        videos=videos,
                        files=files,
                        messages=messages,
                        retries=retries,
                        **kwargs,
                    )
                    if restorer_response is None or not restorer_response.content:
                        restore_retry_times += 1
                        continue
                    else:
                        break

                if restorer_response is None or not restorer_response.content:
                    arbitrator_response.content["message"] += (
                        "\n" + "Sorry, restorer could not provide a response."
                    )
                else:
                    arbitrator_response.content["message"] += (
                        "\n" + restorer_response.content
                    )

            return arbitrator_response
        except Exception as e:
            logger.error(f"Error in trinity: {e}")
        finally:
            for mcp_tool in self.mcp_tools:
                await mcp_tool.__aexit__(None, None, None)


class WorkerModification(BaseModel):
    modified_time: str = Field(default="", description="modified time")
    target: str = Field(
        default="",
        description="modified target, including file, folder, registry, etc.",
    )
    original_content: str = Field(default="", description="original content")
    modified_content: str = Field(default="", description="modified content")
    worker_name: str = Field(default="", description="worker name")
    worker_id: str = Field(default="", description="worker id")


class WorkerResponse(BaseModel):
    env_info: List[WorkerModification] = Field(
        ...,
        description="All modifications made by the worker to the environment will be recorded item by item, including complete original environment information",
    )
    message: str = Field(
        ..., description="The worker's response to the user's request."
    )


class CheckerResponse(BaseModel):
    status: bool = Field(
        ...,
        description="True if the response meets the user's requirements, False otherwise.",
    )
    message: str = Field(
        ...,
        description="Explanation of why the response meets or does not meet the user's requirements.",
    )


class ArbitratorResponse(BaseModel):
    status: bool = Field(
        ..., description="True if the checker conclusion is correct, False otherwise."
    )
    message: str = Field(
        ...,
        description=dedent(
            """
        Explanation of why the checker conclusion is correct or incorrect.
        - if the checker is correct, give the worker reponse, checker reponse, and explain why the checker is correct. Also suggest user to retry the task or tell user that this trinity cannot do this task.
        - if the checker is incorrect, give the worker reponse, checker reponse, and explain why the checker is incorrect. Also tell user the checker meet some error, and suggest user to retry the task or tell user that this trinity cannot do this task.
    """
        ),
    )
